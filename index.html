<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Juego: Asalto a la casa (3 pisos)</title>
  <style>
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:#111;color:#fff;font-family:Inter,Segoe UI,Arial}
    #wrap{display:flex;align-items:center;justify-content:center;height:100%;padding:12px}
    canvas{background:#233;background-image:linear-gradient(#6a8fb6 0%, #233 60%);border-radius:8px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
    .hud{position:fixed;left:16px;top:16px;color:#fff;font-weight:700;text-shadow:0 2px 6px rgba(0,0,0,0.6)}
    .controls{position:fixed;right:16px;top:16px;color:#fff;font-size:13px;opacity:0.9}
    .credits{position:fixed;right:16px;bottom:16px;color:#ddd;font-size:12px}
  </style>
</head>
<body>
<div id="wrap"><canvas id="game" width="900" height="640"></canvas></div>
<div class="hud" id="hud">Salud: 100 • Enemigos: 0 • Piso: 1</div>
<div class="controls">Mover: WASD o Flechas • Apuntar: Ratón • Disparar: Click/Espacio • Subir/Bajar: E/Q</div>
<div class="credits">Creado por ChatGPT — Pide mejoras: enemigos, IA, sprites</div>
<script>
// Juego: Asalto a una casa de 3 pisos.
// Mecánicas: Mover, apuntar con ratón, disparar, subir/bajar pisos por escaleras, enemigos patrullan y disparan.
// Objetivo: eliminar a todos los enemigos en la casa.

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
let keys = {};
let mouse = {x:0,y:0,down:false};

// Game state
let gameState = 'playing';
let score = 0;

// House layout: 3 pisos, cada piso es una franja horizontal
const floors = 3;
const floorHeight = Math.floor(H / floors); // from top (floor 3 at top?) We'll number 1 bottom to 3 top

// Player
const player = {
  x: W/2,
  y: H - floorHeight/2,
  w: 26,
  h: 36,
  speed: 3.8,
  health: 100,
  reload: 0,
  fireRate: 10, // frames
  dmg: 20,
  facing: 0,
  floor: 1
};

// Enemies array
let enemies = [];
let enemyId = 0;

// Bullets
let bullets = [];

// Stair positions (x coordinates where you can change floors)
const stairs = [
  {x:80,yFloors:[H - floorHeight + 30, H - floorHeight - floorHeight + 30, H - floorHeight - floorHeight*2 + 30]},
  {x:W - 120,yFloors:[H - floorHeight + 30, H - floorHeight - floorHeight + 30, H - floorHeight - floorHeight*2 + 30]}
];

// Spawn enemies per floor
function initEnemies(){
  enemies = [];
  enemyId = 0;
  const countPerFloor = [3,4,5]; // bottom to top
  for(let f=1; f<=3; f++){
    for(let i=0;i<countPerFloor[f-1];i++){
      spawnEnemy(f);
    }
  }
}

function spawnEnemy(floor){
  const margin = 140;
  const yCenter = H - floorHeight*floor + floorHeight/2;
  const x = margin + Math.random()*(W - margin*2);
  const y = yCenter + (Math.random()-0.5)*20;
  const speed = 1 + Math.random()*1.2;
  const hp = 40 + Math.floor(Math.random()*30);
  enemies.push({id:enemyId++, x,y,w:26,h:34, floor, speed, hp, maxhp:hp, dir: Math.random()<0.5? -1:1, patrolRange:100 + Math.random()*120, baseX:x, shootTimer: 60 + Math.random()*80});
}

// Input
window.addEventListener('keydown', e=>{keys[e.key.toLowerCase()] = true; if(e.key===' '){mouse.down = true;} });
window.addEventListener('keyup', e=>{keys[e.key.toLowerCase()] = false; if(e.key===' '){mouse.down = false;} });
canvas.addEventListener('mousemove', e=>{const r=canvas.getBoundingClientRect(); mouse.x=(e.clientX-r.left)*(canvas.width/r.width); mouse.y=(e.clientY-r.top)*(canvas.height/r.height);});
canvas.addEventListener('mousedown', e=>{mouse.down = true;});
canvas.addEventListener('mouseup', e=>{mouse.down = false;});
canvas.addEventListener('touchstart', e=>{const t=e.touches[0];const r=canvas.getBoundingClientRect(); mouse.x=(t.clientX-r.left)*(canvas.width/r.width); mouse.y=(t.clientY-r.top)*(canvas.height/r.height); mouse.down=true;});
canvas.addEventListener('touchmove', e=>{const t=e.touches[0];const r=canvas.getBoundingClientRect(); mouse.x=(t.clientX-r.left)*(canvas.width/r.width); mouse.y=(t.clientY-r.top)*(canvas.height/r.height);});
canvas.addEventListener('touchend', e=>{mouse.down=false;});

function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

// Shooting
function fireBullet(x,y,tx,ty,owner){
  const dx = tx - x; const dy = ty - y; const mag = Math.hypot(dx,dy); if(mag===0) return;
  const vx = dx/mag*8; const vy = dy/mag*8;
  bullets.push({x,y,vx,vy,owner,life:120});
}

// Update
function update(){
  if(gameState !== 'playing') return;

  // player movement
  const onFloorY = (f)=> H - floorHeight*f + floorHeight/2;
  let moveX = 0, moveY = 0;
  if(keys['arrowleft']||keys['a']) moveX = -1;
  if(keys['arrowright']||keys['d']) moveX = 1;
  if(keys['arrowup']||keys['w']) moveY = -1;
  if(keys['arrowdown']||keys['s']) moveY = 1;
  player.x += moveX * player.speed;
  player.x = clamp(player.x, 30, W-30);
  // Allow small vertical adjust inside floor
  player.y += moveY * player.speed;
  const targetY = onFloorY(player.floor) + (floorHeight/2 - player.h/2) - 20;
  player.y = clamp(player.y, targetY - 20, targetY + 20);

  // change floors: E subir, Q bajar
  if(keys['e']){ // subir si cerca de escalera and not top
    for(const s of stairs){
      const sx = s.x; const sy = s.yFloors[player.floor-1];
      if(Math.abs(player.x - sx) < 36){ if(player.floor < 3){ player.floor++; player.y = onFloorY(player.floor); } }
    }
    keys['e'] = false; // prevent repeat
  }
  if(keys['q']){ // bajar
    for(const s of stairs){
      const sx = s.x; const sy = s.yFloors[player.floor-1];
      if(Math.abs(player.x - sx) < 36){ if(player.floor > 1){ player.floor--; player.y = onFloorY(player.floor); } }
    }
    keys['q'] = false;
  }

  // aim
  player.facing = Math.atan2(mouse.y - player.y, mouse.x - player.x);

  // firing
  if(player.reload > 0) player.reload--; 
  if(mouse.down && player.reload === 0){ fireBullet(player.x, player.y - player.h/2, mouse.x, mouse.y, 'player'); player.reload = player.fireRate; }

  // update bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.x += b.vx; b.y += b.vy; b.life--;
    // bounds
    if(b.x < -50 || b.x>W+50 || b.y<-50 || b.y>H+50 || b.life<=0){ bullets.splice(i,1); continue; }
    // collisions: if owner player, hit enemies same floor
    if(b.owner==='player'){
      for(let j=enemies.length-1;j>=0;j--){ const e=enemies[j]; if(e.floor !== player.floor) continue;
        if(pointInRect(b.x,b.y,e.x - e.w/2, e.y - e.h/2, e.w, e.h)){
          e.hp -= player.dmg; bullets.splice(i,1); if(e.hp<=0){ enemies.splice(j,1); score++; } break;
        }
      }
    } else { // enemy bullet hits player if same floor
      if(b.owner && b.owner.type === 'enemy' && b.owner.floor === player.floor){
        if(pointInRect(b.x,b.y, player.x - player.w/2, player.y - player.h, player.w, player.h + 12)){
          player.health -= 12; bullets.splice(i,1);
          if(player.health <=0) gameState='dead';
        }
      }
    }
  }

  // update enemies
  for(const e of enemies){
    // simple patrol
    e.baseX += 0; // base static
    e.x += e.dir * e.speed;
    if(Math.abs(e.x - e.baseX) > e.patrolRange) e.dir *= -1;
    // clamp inside margins
    e.x = clamp(e.x, 40, W-40);

    // line of sight: if player on same floor and within X, aim and shoot occasionally
    e.shootTimer--;
    if(e.floor === player.floor){
      const dx = player.x - e.x; const dy = player.y - e.y; const dist = Math.hypot(dx,dy);
      if(dist < 380){
        if(e.shootTimer <=0){
          // fire
          const angle = Math.atan2(player.y - e.y, player.x - e.x);
          bullets.push({x:e.x, y:e.y, vx:Math.cos(angle)*5, vy:Math.sin(angle)*5, owner:{type:'enemy',id:e.id, floor:e.floor}, life:160});
          e.shootTimer = 80 + Math.random()*80;
        }
      }
    }
  }

  // update HUD
  document.getElementById('hud').innerText = `Salud: ${Math.max(0,Math.round(player.health))} • Enemigos: ${enemies.length} • Piso: ${player.floor}`;

  // win/lose checks
  if(enemies.length === 0){ gameState = 'win'; }
}

function pointInRect(px,py,rx,ry,rw,rh){return px>=rx && px<=rx+rw && py>=ry && py<=ry+rh;}

// Draw
function draw(){
  // clear
  ctx.clearRect(0,0,W,H);

  // draw floors
  for(let f=3; f>=1; f--){
    const top = H - floorHeight*f;
    // floor background
    ctx.fillStyle = f===player.floor ? '#2e2e2e' : '#1f1f1f';
    ctx.fillRect(0, top, W, floorHeight - 2);
    // windows / decor
    ctx.fillStyle = '#2a3b4a';
    ctx.fillRect(10, top+12, 80, 32);
    // stairs positions
    ctx.fillStyle = '#6b5a3a';
    for(const s of stairs){ ctx.fillRect(s.x - 18, top + floorHeight - 80, 36, 80); }
    // floor label
    ctx.fillStyle = '#bbb'; ctx.font = '14px monospace'; ctx.fillText('Piso '+f, 14, top + 24);
  }

  // draw stairs highlights
  for(const s of stairs){
    for(let f=1; f<=3; f++){
      const sy = H - floorHeight*f + floorHeight - 80;
      ctx.fillStyle = 'rgba(255,255,255,0.03)'; ctx.fillRect(s.x - 18, sy, 36, 80);
    }
  }

  // draw player (on its floor)
  drawEntity(player, true);

  // draw enemies
  for(const e of enemies){ drawEntity(e, false); drawEnemyHP(e); }

  // bullets
  for(const b of bullets){ ctx.beginPath(); ctx.arc(b.x,b.y,4,0,Math.PI*2); ctx.fillStyle = '#ffd'; ctx.fill(); }

  // overlays
  if(gameState === 'win'){
    ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(W*0.18, H*0.3, W*0.64, H*0.28);
    ctx.fillStyle = '#b9ffb9'; ctx.font = '36px monospace'; ctx.fillText('¡Misión cumplida!', W*0.34, H*0.45);
    ctx.fillStyle = '#fff'; ctx.font = '18px monospace'; ctx.fillText('Presiona R para jugar otra vez', W*0.33, H*0.52);
  }
  if(gameState === 'dead'){
    ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(W*0.18, H*0.3, W*0.64, H*0.28);
    ctx.fillStyle = '#ff9a9a'; ctx.font = '36px monospace'; ctx.fillText('Has muerto', W*0.38, H*0.45);
    ctx.fillStyle = '#fff'; ctx.font = '18px monospace'; ctx.fillText('Presiona R para reiniciar', W*0.33, H*0.52);
  }
}

function drawEntity(ent, isPlayer){
  const top = H - floorHeight*ent.floor;
  // body
  ctx.save();
  ctx.translate(ent.x, ent.y);
  // shadow
  ctx.beginPath(); ctx.ellipse(0, ent.h/2 + 6, ent.w*0.6, 6, 0,0,Math.PI*2); ctx.fillStyle='rgba(0,0,0,0.4)'; ctx.fill();
  // torso
  ctx.fillStyle = isPlayer ? '#4ea8f7' : '#c7544a';
  roundRect(ctx, -ent.w/2, -ent.h, ent.w, ent.h, 6, true, false);
  // head
  ctx.beginPath(); ctx.arc(0, -ent.h - 8, 10, 0, Math.PI*2); ctx.fillStyle = '#f1d6b3'; ctx.fill();
  // weapon: simple rectangle rotated for player
  ctx.save();
  if(isPlayer){ ctx.rotate(player.facing); ctx.fillStyle = '#222'; ctx.fillRect(8, -ent.h/2 - 4, 18, 6); }
  else {
    // enemy aims a bit towards player when same floor
    const ang = Math.atan2(player.y - ent.y, player.x - ent.x);
    ctx.rotate(ang);
    ctx.fillStyle = '#2b2b2b'; ctx.fillRect(8, -ent.h/2 - 4, 16, 6);
  }
  ctx.restore();
  ctx.restore();
}

function drawEnemyHP(e){
  const px = e.x - 24, py = e.y - e.h - 22;
  ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(px, py, 48, 8);
  ctx.fillStyle = '#ff6b6b'; ctx.fillRect(px+1, py+1, Math.max(0,46*(e.hp/e.maxhp)), 6);
}

function roundRect(ctx, x, y, w, h, r, fill, stroke){ if(typeof r==='undefined') r=6; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); if(fill) ctx.fill(); if(stroke) ctx.stroke(); }

// reset
function reset(){ player.x = W/2; player.floor = 1; player.y = H - floorHeight/2; player.health = 100; bullets=[]; initEnemies(); gameState='playing'; score=0; }

// helper for key R to restart
window.addEventListener('keydown', e=>{ if(e.key.toLowerCase() === 'r'){ reset(); } });

// initialize
initEnemies();

// main loop
function loop(){ update(); draw(); requestAnimationFrame(loop); }
loop();

</script>
</body>
</html>

